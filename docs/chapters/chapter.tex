introduction:

Source: https://www.vik.bme.hu/fmd/539.html
Source: https://www.bme.hu/sites/default/files/csatolmanyok/
                tenyek\_es\_adatok\_2017\_18\_mod.pdf

Thanking:
Pintér Richárd, Gyori Erzsébet, Tevesz Gábor, Asztalos Márk, Kárpinszky András, En-Co Software Kft., Nemkin Róbert.

Market analysis:

Source:
Gyori Erzsébet (requirements)
https://www.timetabler.com/
https://www.unitime.org/
https://www.youtube.com/watch?v=anUOP14l1QE
https://www.youtube.com/watch?v=0S9DQiG6hXo


Framework

Many frameworks and programming languages exist that can be used to solve problems with COP.

Declarative programming languages such as Prolog or Erlang would be a good fit. However they are hard to create UIs for and hard to connect to databases. Typical UI applications are not easy in these languages.

I choose Google's OR-tools as a toolkit because it is open source, it has a C++ framework and I wanted to use C++. Google is a company that solves these problems a lot so I thought this is they use so its good.
I choose Google's OR-tools because:
- It is open source.
- I trust Google to make good programs.
- It had many solvers not just COP so it would be convenient to change.

Architecture

The architecture consists of 3 parts:
- The database is responsible for storing every data.  I used PostgreSQL for the database since it can be run on a different computer, contains user authentication and highly convenient.

Data model:

I suspected the data model would change throughout the semester so I constructed a Python program that automatically generates my C++11 classes from a table.

Type model json:
I described  the types I can use the following way: What the C++ type should be for it, what the SQL type should be for it and the default value of it.
{
    "id": {
        "cpp": "int", 
        "sql": "SERIAL PRIMARY KEY",
        "default\_value": "0"
    },
    "reference": {
        "cpp": "int",
        "sql": "INTEGER",
        "default\_value": "0"
    },
    "int": {
        "cpp": "int",
        "sql": "INTEGER",
        "default\_value": "0"
    },
    "double": {
        "cpp": "double",
        "sql": "DOUBLE PRECISION",
        "default\_value": "0.0"
    },
    "text": {
        "cpp": "std::string",
        "sql": "TEXT",
        "default\_value": "\\"\\""
    },
    "bool": {
        "cpp": "bool",
        "sql": "BOOLEAN",
        "default\_value": "false"
    },
    "timestamp": {
        "cpp": "std::string",
        "sql": "TIMESTAMP",
        "default\_value": "\\"\\"" 
    }
}

Then my classes look like this:

Default is what every class has. Every class also has an id which is the primary key.

The references will translate to a foreign key in the database.

I changed the data model quite a lot during the semester. This way of describing it allowed me to quickly iterate through the new way of the model and so I was able to work much faster compared to having done it manually.

I also auto generated the database.

{
    "default": {
        "members": [
            {
                "name": "modified\_timestamp",
                "type": "timestamp"
            },
            {
                "name": "is\_deleted",
                "type": "bool"
            }
        ]
    },
    "classes": [
        {
            "class": "timeslot",
            "members": [
                {
                    "name": "name",
                    "type": "text"
                }
            ],
            "references": []
        },
        {
            "class": "location",
            "members": [
                {
                    "name": "name",
                    "type": "text"
                }
            ],
            "references": []
        },
        {
            "class": "class\_type",
            "members": [
                {
                    "name": "name",
                    "type": "text"
                }
            ],
            "references": []
        },
        {
            "class": "year",
            "members": [
                {
                    "name": "name",
                    "type": "text"
                }
            ],
            "references": []
        },
        {
            "class": "room",
            "members": [
                {
                    "name": "name",
                    "type": "text"
                },
                {
                    "name": "size\_type",
                    "type": "text"
                }
            ],
            "references": [
                {
                    "class": "location"
                },
                {
                    "class": "class\_type"
                }
            ]
        },
        {
            "class": "department",
            "members": [
                {
                    "name": "name",
                    "type": "text"
                },
                {
                    "name": "short\_name",
                    "type": "text"
                }
            ],
            "references": []
        },
        {
            "class": "course",
            "members": [
                {
                    "name": "name",
                    "type": "text"
                }
            ],
            "references": [
                {
                    "class": "year"
                },
                {
                    "class": "department"
                }
            ]
        },
        {
            "class": "class",
            "members": [
                {
                    "name": "name",
                    "type": "text"
                }
            ],
            "references": [
                {
                    "class": "class\_type"
                },
                {
                    "class": "course"
                }
            ]
        },
        {
            "class": "faculty\_member",
            "members": [
                {
                    "name": "name",
                    "type": "text"
                }
            ],
            "references": [
                {
                    "class": "department"
                }
            ]
        },
        {
            "class": "license",
            "members": [],
            "references": [
                {
                    "class": "course"
                },
                {
                    "class": "class\_type"
                },
                {
                    "class": "faculty\_member"
                }
            ]
        }
    ]
}

And I can create these from a simple json. Quite good.

Then I went further and created a google docs where I could just create the database and download its descriptors and the update functions.

Table screenshot.

Google script downloader.




Backend development

Simple model
https://developers.google.com/optimization/cp/original\_cp\_solver
- Original Google CP solver. Extra slow. Took 1 day. Changed it to CP solver, it took 3 minutes. Appears to be old code which is kept because in some small input cases it is better.


- Practice sessions could overlap

Mathematical equationsx
Proof of the minimalisation.

ja a bizonyítás úgy fog kinézni hogy vegyünk egy órarendet amiben van lyukas óra
erre belátjuk hogy létezik olyan óra amit a lyukasóra helyére mozgatva csökken a lyukasórák száma
válasszuk ki a legelsöt a héten és mozgassuk át a lyukas óra helyére
nyilván ilyenkor a páronkénti távolságok azokra a párokra amiben nincs benne a kiválasztott nem változtak
maradtak azok a párok amikben az egyik a kiválasztott
és akkor erre kell belátni hogy ha
kiválasztott, szám szám szám üres szám szám szám
helyett
szám szám szám kiválasztott szám szám szám van
az kisebb távolságot eredményez
erre meg tök ugyanaz a bizonyítás
mint arra hogy a számtani közép az a szám ami n db számtól vett távolság átlagát minimalizálja
erre belátjuk hogy létezik olyan óra amit a lyukasóra helyére mozgatva csökken a *páronkénti távolságok összege*
elírtam
tehát semelyik olyan órarend nem lehet minimális páronkénti távolságösszegű amiben van lyukasóra mert a lyukasóra helyére mozgatva
a legelsö órát csökkenteni lehet a páronkénti távolságokat
Q.E.D

Frontend development

Qt. Screenshots.

Tests:

Supergraphs.

Q.: Why is timetable planning a multivariable optimisation problem? Why can we use operations research to solve it?

Q.: What are multi-variable target functions? How do we optimise them?

Q.: What methods are present for multi-variable optimisation?

Q.: How can we use operations research to solve real-life problems? Why is it important?

Q.: Where do they use operations research?

Q.: What languages, frameworks are available that implement these techniques? 

Q.: Why did I choose OR-tools?


Q.: The student's job is to implement multi-variable optimisation in a timetabling application for universities.

Q.: What type of algorithm did I choose, [why did I choose that]? How I designed it?

Q.: How I implemented the algorithm?

What equalities did we use and how we implemented the server side?
- Every class has a teacher and a room assigned.
- No student or teacher has to be in more than one place at one time.
- No double-booked rooms.
- The appointed room must fit the number of students in the class and have the necessary equipment for it.

Q.: How can we verify its correctness?

Q.: How I verified it?

Q.: What example datasets I used?

Q.: How I customised the algorithm? (Did I make it faster? Better?)

Q.: How I created the user interface?

Q.: What is Qt? How can we use Qt?

Q.: What other tools I used?
- Git/Github
- VIM
- Etc?

Q: How I generate the code from the model?
Q: Bad models? Generate all proposals and throw out the ones within conflict?
Q: Non-SAT CP solver.
Q: All exercise/labours at the same timeslot.

